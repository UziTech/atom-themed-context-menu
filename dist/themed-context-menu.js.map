{
  "version": 3,
  "sources": ["../src/main.ts", "../src/MenuItem.ts", "../src/ThemedContextMenu.ts"],
  "sourcesContent": ["import { ThemedContextMenu } from \"./ThemedContextMenu\"\nimport { ContextElement } from \"./ContextElement\"\n\nlet tcm = new ThemedContextMenu()\n// let elemList: ContextElement[] = []\n\nexport function activate() {\n    console.log(\"hello!\")\n    tcm.hijackFunction()\n    // let contextMenu = atom.contextMenu as any\n    // console.log(contextMenu)\n    // console.log(contextMenu.showForEvent)\n\n    // contextMenu.showForEvent = (e) => {\n    //     let data = contextMenu.templateForEvent(e)\n    //     receiveContextMenu(data)\n    // }\n\n    // gather context element into element list and hijack the event listener\n    // gatherContextElements()\n    // hijackAllContextMenus()\n}\n\nexport function deactivate() {\n    // release the event listeners\n    console.log(\"goodbye!\")\n    tcm.releaseFunction()\n}\n\n// function receiveContextMenu(data) {\n//     console.log(data)\n// }\n\n// function gatherContextElements() {\n// ask atom for context menu items and dom selectors\n// let contextMenuItems = (atom.contextMenu as any).itemSets\n\n// let workingList: ContextElement[] = []\n// for (let i = 0; i < contextMenuItems.length; i++) {\n//     let triggeringItem = contextMenuItems[i]\n\n// get all dom elements that match selector\n// let domElems = document.querySelectorAll(triggeringItem.selector)\n// if (domElems.length === 0) {\n//     console.log(triggeringItem)\n// }\n// create context element objects and add to elemlist\n//     domElems.forEach((item) =>\n//         workingList.push(new ContextElement(item, triggeringItem.items)),\n//     )\n// }\n\n// remove duplicates from elemlist and assign to public variable\n// elemList = pruneElements(workingList)\n// }\n\n// wrapper function to ask all context elements to hijack the context menu event\n// function hijackAllContextMenus() {\n// elemList.forEach((item) => item.hijackContextMenu(tcm))\n// }\n\n// wrapper function to ask all context elements to release the context menu event\n// function unhijackAllContextMenus() {\n// elemList.forEach((item) => item.unhijackContextMenu(tcm))\n// }\n\n// join different context menu item sets for same dom elements\n// function pruneElements(elements: ContextElement[]): ContextElement[] {\n//     for (let i = 0; i < elements.length; i++) {\n//         for (let j = i + 1; j < elements.length; j++) {\n//             if (elements[i].getElem() === elements[j].getElem()) {\n//                 elements[i].mergeContextElement(elements[j])\n//                 elements.splice(j, 1)\n//             }\n//         }\n//     }\n//\n//     return elements\n// }\n", "import EventEmitter from \"events\"\nimport { ContextMenuItem } from \"./types\"\nimport { ThemedContextMenu } from \"./ThemedContextMenu\"\n\n// handler for the items shown in the context menu, be it a separator or a command\nexport class MenuItem {\n    private element: HTMLHRElement | HTMLDivElement\n    private command?: string\n    private commandDetail?: string\n    private selected: boolean = false\n    private parent: ThemedContextMenu\n    private height: number\n\n    private constructor(\n        element: HTMLHRElement | HTMLDivElement,\n        parent: ThemedContextMenu,\n        height: number,\n    ) {\n        this.element = element\n        this.parent = parent\n        this.height = height\n\n        this.element.addEventListener(\"click\", (e) =>\n            this.onMouseClick(e as MouseEvent),\n        )\n    }\n\n    // static function wrapper to create a MenuItem object from a ContextMenuItem object\n    public static createMenuItem(\n        item: ContextMenuItem,\n        parent: ThemedContextMenu,\n    ): MenuItem {\n        // early return for separators\n        if (item.type === \"separator\") {\n            return new MenuItem(document.createElement(\"hr\"), parent, 7)\n        }\n\n        // create base menu item div element and create menu item object from base div\n        const divElem = document.createElement(\"div\")\n        divElem.classList.add(\"menu-item\")\n        const self = new MenuItem(divElem, parent, 23)\n\n        // create menu item label span\n        const menuItemName = document.createElement(\"span\")\n        menuItemName.classList.add(\"menu-item-name\")\n        // if it doesnt have a label, what is it?\n        // i guess a separator wont have a label, but other than that?\n        // should i add an early return case for this?\n        menuItemName.innerHTML = item.label ? item.label : \"\"\n\n        // create menu item key stroke span\n        const menuItemKey = document.createElement(\"span\")\n        menuItemKey.classList.add(\"menu-item-key\")\n\n        // append menu item elements to base menu item div\n        divElem.appendChild(menuItemName)\n        divElem.appendChild(menuItemKey)\n\n        // if it doesnt have a command it might be a submenu\n        if (item.command !== undefined) {\n            // add command data to menu item object\n            self.command = item.command\n            self.commandDetail = item.commandDetail\n\n            // if it has a command, it might have a keymap, so search for it\n            const keyStrokes = atom.keymaps.findKeyBindings({\n                command: item.command,\n            })\n\n            // if it has a keymap, add it to the item key span element\n            if (keyStrokes.length > 0) {\n                menuItemKey.innerHTML =\n                    keyStrokes[keyStrokes.length - 1].keystrokes\n            }\n        }\n\n        return self\n    }\n\n    // on click, execute command and hide the context menu\n    private onMouseClick(e: MouseEvent) {\n        e.stopPropagation()\n        this.execCommand()\n        this.parent.deleteContextMenu()\n    }\n\n    private async execCommand(): Promise<void> {\n        if (this.command === undefined) {\n            return\n        }\n\n        let target =\n            (atom.workspace.getActiveTextEditor() as any)?.getElement() ||\n            (atom.workspace.getActivePane() as any).getElement()\n\n        await (atom.commands as any).dispatch(\n            target,\n            this.command,\n            this.commandDetail,\n        )\n    }\n\n    public getElement(): HTMLElement {\n        return this.element\n    }\n\n    public getHeight(): number {\n        return this.height\n    }\n}\n", "import { MenuItem } from \"./MenuItem\"\nimport { MouseClick } from \"./types\"\n\nexport class ThemedContextMenu {\n    private hijackedFunction: Function | undefined\n    private activeContextMenu: HTMLDivElement\n    private visible: boolean = false\n    private children: MenuItem[] = []\n    private lastClick: MouseClick | undefined\n    private windowBlurObserver: MutationObserver\n\n    constructor() {\n        // add click listener to clear the context menu\n        document.addEventListener(\"click\", (e) =>\n            this.onMouseClick(e as MouseEvent),\n        )\n\n        // add blur listener to clear the context menu\n        const body = document.querySelector(\"body\")\n        this.windowBlurObserver = new MutationObserver((e) =>\n            this.windowBlurCallback(e, this),\n        )\n        if (body) {\n            this.windowBlurObserver.observe(body, {\n                attributeFilter: [\"class\"],\n            })\n        }\n\n        // create the context menu, but make it invisible\n        this.activeContextMenu = document.createElement(\"div\")\n        this.activeContextMenu.classList.add(\"themed-context-menu\")\n        this.activeContextMenu.classList.add(\"invisible\")\n\n        let aws = document.querySelector(\"atom-workspace\")\n        aws?.appendChild(this.activeContextMenu)\n    }\n\n    // hijack context menu event function\n    hijackFunction() {\n        let contextMenuManager = atom.contextMenu as any\n        this.hijackedFunction = contextMenuManager.showForEvent\n        contextMenuManager.showForEvent = (e) => {\n            let data = contextMenuManager.templateForEvent(e)\n            this.displayContext(e, data)\n        }\n    }\n\n    releaseFunction() {\n        let contextMenuManager = atom.contextMenu as any\n        contextMenuManager.showForEvent = this.hijackedFunction\n    }\n\n    displayContext(e: MouseClick, items) {\n        // if mouse event is different to last, clear context menu\n        // if (this.lastClick !== undefined && this.lastClick !== e) {\n        this.deleteContextMenu()\n        // }\n\n        // set last click event to current parameter,\n        // make context menu visible\n        this.visible = true\n        // this.lastClick = e\n        this.activeContextMenu.classList.remove(\"invisible\")\n\n        // add context menu items to context menu\n        items.forEach((element) => {\n            this.addChild(element)\n        })\n\n        // move context menu position to mouse event position\n        this.activeContextMenu.setAttribute(\n            \"style\",\n            this.getPositionStyleString(e),\n        )\n    }\n\n    displayContextMenu(e: MouseClick, items) {\n        // if mouse event is different to last, clear context menu\n        if (this.lastClick !== undefined && this.lastClick !== e) {\n            this.deleteContextMenu()\n        }\n\n        // set last click event to current parameter,\n        // make context menu visible\n        this.visible = true\n        this.lastClick = e\n        this.activeContextMenu.classList.remove(\"invisible\")\n\n        // add context menu items to context menu\n        items.forEach((element) => {\n            this.addChild(element)\n        })\n\n        // move context menu position to mouse event position\n        this.activeContextMenu.setAttribute(\n            \"style\",\n            this.getPositionStyleString(e),\n        )\n    }\n\n    private windowBlurCallback(mutation, tcm: ThemedContextMenu) {\n        // need to pass in the tcm through params because 'this' is the\n        // MutationObserver in this function\n        // tcm.deleteContextMenu()\n    }\n\n    // adds a context menu item to context menu\n    private addChild(item) {\n        const mitem = MenuItem.createMenuItem(item, this)\n        this.children.push(mitem)\n        this.activeContextMenu?.appendChild(mitem.getElement())\n    }\n\n    private onMouseClick(e) {\n        this.deleteContextMenu()\n    }\n\n    // generates a style string that positions the context menu next to\n    // mouse event, while also preventing it from overflowing\n    private getPositionStyleString(e: MouseClick): string {\n        let x = e.clientX + 10 + 5\n        let y = e.clientY + 5\n\n        x = Math.min(x, window.innerWidth - 310)\n        y = Math.min(y, window.innerHeight - this.getHeight() - 10)\n\n        return \"top:\" + y + \"px; left:\" + x + \"px\"\n    }\n\n    // calculate context menu height for positioning function\n    private getHeight(): number {\n        return this.children\n            .map((item) => item.getHeight())\n            .reduce(function (a, b) {\n                return a + b\n            })\n    }\n\n    deleteContextMenu() {\n        if (this.visible) {\n            this.visible = false\n            this.children = []\n            this.activeContextMenu.classList.add(\"invisible\")\n            this.lastClick = undefined\n            this.removeAllChildNodes()\n        }\n    }\n\n    private removeAllChildNodes() {\n        while (this.activeContextMenu.firstChild) {\n            this.activeContextMenu.removeChild(\n                this.activeContextMenu.firstChild,\n            )\n        }\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
